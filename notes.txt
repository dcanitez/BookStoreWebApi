**RDMS (Relational Database Management System)
#Büyük verileri saklama ve yönetme konusunda RDMS ler sıkıntılı çalışıyor.
- SQL(Structured Query Language)
- Data Consistency(tablolar arasındaki ilişkiler verilerin tutarlılığını sağlıyor!)
    * MySql
    * PostgreSql
    * MsSql
    * IBM DB2
    * Oracle
-SQL Server : T-SQL || Oracle : PL-SQL

**NoSQL Databases
#Yüksek trafikle yüksek miktarda verinin yönetimine odaklanmıştır. (RDMS zayıf noktası)
-! Immediate Data Consistency
    Anlık veri tutarlılığından feragat ederler, yüksek performans ve hıza odaklanmıştır.
- Eventual Data Consistency
    Nihai olarak veriler tutarlıdır.

- CAP Teoremi
    * Consistency
        All clients see the same view of data, even right after update or delete
        Dağıtık sistemlerdeki tüm nodelar aynı veriye sahip olması.
    * Availability
        All clients can find a replica of data, even in case of partial node failures
        Sisteme yapılan her istek başarılı ya da başarısız olsa da yanıt alabilir olması.
    * Partition Tolerance
        The system continues to work as expected, even in presence of partial network failure
        Mevcut nodelarda erişilmezlik olduğunda bile sistem kaynakları sürekli çalışır olması.

- Document Based (Mongo DB, Couch DB) 
- Key/Value (Redis)
- Graph Based (Neo4J)
- Column Based (Cassandra, HBase)

RDMS VS NoSQL
--------------
RDMS : -Dikeyde ölçeklenebilir, yatayda ölçeklenmesi çok zordur.(Vertical Scalibility-var olan kaynağını arttırması kaynağın gücünü arttırmak demek, memory arttırımı olarak düşünülebilir.)
NoSQL : -Kolay bir şekilde dikeyde ya da yatayda ölçeklenebilir. Dağıtık sistemler için uygundur. (Horizontal Scalibility-aynı databaseden birçok kopya olabilmesi)

RDMS : -Anlık veri tutarlılığı sunar. (Immediate Data Consistency)
NoSQL : -Nihai veri tutarlılığı sunar. (Eventual Data Consistency)

RDMS : Olgunluk seviyesi yüksektir. Yetişmiş uzman bulmak kolaydır.
NoSQL : Olgun değildir. Yetişmiş uzman bulmak zordur.

RDMS : Lisans ücretleri çok yüksektir.
NoSQL : Lisans ücretleri düşüktür.

**ORM (Object Relational Mapping) && ORM Tools
- RDMS ile uygulama içerisinde kullandığımız model/nesneleri birbirine bağlama tekniğidir.
Db objelerinin Kod tarafında replicasının yaratılması için kullanılan mapleme tekniğidir.

-Tools => Entity Framework, Entity Framework Core, Dapper, nHibernate
    * Db teknolojisine olan bağımlılığı ortadan kaldırır. (DB Dependency ortadan kaldırır.)
    Uygulama yalnızca ORM i bilir.
    Database hakkında bilgisi yoktur.
    * SQL/TSQL/PLSLQ bilmeden kısa bir zamanda ve daha az kodla db işlemlerinin yapılmasını sağlar.
    * OOP yi destekler.
    * ORM araçlarının çoğu açık kaynak kodludur.

    x Performans sorunları yaratabilir. Db ye bağlanıp SQL çalıştırmak her zaman daha performanslıdır.
    x ORM in oluşturduğu SQL lere müdahale edemeyiz. Kontrol developerdan alınmıştır.
    x ORM öğrenmek için de zaman gerekir.

-ORM Approaches; DB First, Code First, Model First

Projeye EF Core Dahil edilirken;
* Nuget Package lar eklendi. 5.0.13 versiyonu ekledim.
Terminalden "dotnet add package Microsoft.EntityFrameworkCore --version 5.0.13" ve 
Inmemory db kullanabilmek için "dotnet add package Microsoft.EntityFrameworkCore.InMemory --version 5.0.13"

*DbOperations dosyası oluşturuldu içerisine ...DbContext.cs class ı oluşturuldu.
* Oluşturulan class EFCore paketinden gelen DbContext nesnesinden inherit alındı.
* Constructor da Contextin DbContextOptions<...DbContext> options parametresinin base(options) olması gerektiği belirtildi.
* Property olarak public DbSet<Book> Books {get;set;} tanımlandı.
* Book nesneleri boş olmaması için DataGenerator.cs file oluşturuldu. 
    İçerisinde Initialize isminde bir method oluşturuldu.
    Context i kullanabilmek için bir var context tanımlaması yapıldı.
    Dependency Injection class ı kullanılarak tanımlaması
        using(var context=new BookStoreDbContext(serviceProvider.GetRequiredService<DbContextOptions<BookStoreDbContext>>()))

        using scope u kullanılarak innermemory databaseine dataların eklenmesini komut verdik.
*Belirtilen DataGenerator class ının tetiklenmesi için Program.cs içerisine tanımlama yapmamız gerekiyor.
Program her ayağa kalktığında tetiklenmesi için Main methodu içerisindeki host kullanıldı.
host değişkenini yakalayıp buna kullanacağı servisi tanımlamak gerekti.
    using(var scope=host.Services.CreateScope())
    {
        var service=scope.ServiceProvider();
        DataGenerator.Initialize(service);
    }
    host.Run();

* Startup.cs dosyası içerisinde ise ConfigureServices metoduna kullanacağımız servisi Inject etmemiz gerekecek.
    services.AddDbContext<BookStoreDbContext>(options=>options.UseInMemoryDatabase(databaseName:"BookStoreDB"));

* Controller class ının constructorında projeye tanımlanan contexti inject ediyoruz.
    private readonly BookStoreDbContext _context;   
    public BookController(BookStoreDbContext context)
    {
        _context=context;
    }

* AutoIncremented primary key için ise key üzerine [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
attribute u tanımlanır.


# LINQ (Language Integrated Query) Operations (CRUD)
-----------------------------------------------------







    


